<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tower Defense Game</title>
  <style>
    body { margin: 0; padding: 0; text-align: center; background: #000; }
    #gameCanvas {
      background: url('https://imgur.com/ARaVPJV.png') no-repeat center center;
      background-size: cover;
      display: block;
      margin: auto;
    }
    #ui {
      position: fixed; top: 10px; left: 10px;
      background: rgba(0,0,0,0.5); color: #fff;
      padding: 10px; font-family: sans-serif; font-size: 14px;
      text-align: left; border-radius: 5px;
    }
    #ui small { font-size: 11px; color: #ccc; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="500"></canvas>
  <div id="ui">
    Score: <span id="score">0</span><br>
    Gold: <span id="gold">0</span><br>
    Wave: <span id="wave">0</span><br>
    Next wave in: <span id="nextWave">0</span>s<br>
    <small>Left-click to place tower, Right-click a tower to upgrade</small>
  </div>
  <script>
    // Immediately Invoked Function to avoid globals
    (() => {
      /** Game Constants and Initial Settings **/
      const CANVAS_WIDTH = 800, CANVAS_HEIGHT = 500;
      const TOWER_SIZE = 40, ENEMY_SIZE = 40;
      const TOWER_COST = 50, BASE_UPGRADE_COST = 50;
      const ENEMY_BASE_HP = 50, ENEMY_HP_INCREMENT = 10;
      const ENEMY_BASE_SPEED = 50, ENEMY_SPEED_INCREMENT = 5;
      const ENEMY_GOLD_DROP = 20;
      const TOWER_DAMAGE = 20, TOWER_RANGE = 100, TOWER_FIRE_RATE = 1.0;
      const TOWER_INITIAL_HP = 100, ENEMY_DAMAGE_TO_TOWER = 50;

      // Game State Variables
      let score = 0;
      let gold = 100;
      let currentWave = 0;
      let waveActive = false;
      let nextWaveTime = 3;
      let enemiesToSpawn = 0;
      let spawnCount = 0;
      const spawnInterval = 0.5;
      let spawnTimer = 0;

      // Game Object Arrays
      const towers = [];
      const enemies = [];
      const bullets = [];

      // Path waypoints for enemies
      const path = [
        { x: 0, y: 250 },
        { x: 400, y: 250 },
        { x: 400, y: 400 },
        { x: 800, y: 400 }
      ];

      // Canvas and UI element references
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const scoreEl = document.getElementById('score');
      const goldEl = document.getElementById('gold');
      const waveEl = document.getElementById('wave');
      const nextWaveEl = document.getElementById('nextWave');

      // Load tower and enemy images with fallback
      const towerImg = new Image();
      const enemyImg = new Image();
      towerImg.src = "https://imgur.com/wLQWu8s.png";
      enemyImg.src = "https://imgur.com/hNQo8cQ.png";
      let assetsLoaded = 0;
      let imagesFailed = false;

      // Image load/error handlers
      function handleAssetLoad() {
        assetsLoaded++;
        if (assetsLoaded === 2 || imagesFailed) {
          console.log('Starting game loop. Assets loaded:', assetsLoaded);
          requestAnimationFrame(gameLoop);
        }
      }

      function handleAssetError(img) {
        console.error(`Failed to load image: ${img.src}`);
        imagesFailed = true;
        assetsLoaded++;
        if (assetsLoaded === 2) {
          console.log('Starting game loop with fallback graphics');
          requestAnimationFrame(gameLoop);
        }
      }

      towerImg.onload = handleAssetLoad;
      enemyImg.onload = handleAssetLoad;
      towerImg.onerror = () => handleAssetError(towerImg);
      enemyImg.onerror = () => handleAssetError(enemyImg);

      // Disable context menu on right-click
      canvas.addEventListener('contextmenu', e => e.preventDefault());

      /** Helper function: distance between two points **/
      function dist(ax, ay, bx, by) {
        return Math.hypot(bx - ax, by - ay);
      }

      /** Spawn a new enemy at the start of the path **/
      function spawnEnemy() {
        const hp = ENEMY_BASE_HP + (currentWave - 1) * ENEMY_HP_INCREMENT;
        const speed = ENEMY_BASE_SPEED + (currentWave - 1) * ENEMY_SPEED_INCREMENT;
        const spawnX = path[0].x, spawnY = path[0].y;
        enemies.push({
          x: spawnX,
          y: spawnY,
          hp: hp,
          maxHp: hp,
          speed: speed,
          waypointIndex: 1,
          remove: false
        });
      }

      /** Start the next wave of enemies **/
      function startWave() {
        waveActive = true;
        currentWave += 1;
        spawnCount = 0;
        enemiesToSpawn = currentWave * 3 + 1;
        spawnTimer = 0;
      }

      /** Event: Left-click to place a new tower **/
      canvas.addEventListener('click', e => {
        const rect = canvas.getBoundingClientRect();
        const cx = e.clientX - rect.left;
        const cy = e.clientY - rect.top;
        for (let tower of towers) {
          if (Math.abs(cx - tower.x) < TOWER_SIZE/2 && Math.abs(cy - tower.y) < TOWER_SIZE/2) {
            return;
          }
        }
        if (gold >= TOWER_COST) {
          for (let tower of towers) {
            if (dist(cx, cy, tower.x, tower.y) < TOWER_SIZE) {
              return;
            }
          }
          gold -= TOWER_COST;
          const tx = Math.max(TOWER_SIZE/2, Math.min(CANVAS_WIDTH - TOWER_SIZE/2, cx));
          const ty = Math.max(TOWER_SIZE/2, Math.min(CANVAS_HEIGHT - TOWER_SIZE/2, cy));
          towers.push({
            x: tx,
            y: ty,
            hp: TOWER_INITIAL_HP,
            maxHp: TOWER_INITIAL_HP,
            damage: TOWER_DAMAGE,
            range: TOWER_RANGE,
            fireRate: TOWER_FIRE_RATE,
            cooldown: 0,
            level: 1,
            remove: false
          });
        }
      });

      /** Event: Right-click on a tower to upgrade it **/
      canvas.addEventListener('contextmenu', e => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const cx = e.clientX - rect.left;
        const cy = e.clientY - rect.top;
        for (let tower of towers) {
          if (Math.abs(cx - tower.x) < TOWER_SIZE/2 && Math.abs(cy - tower.y) < TOWER_SIZE/2) {
            const upgradeCost = BASE_UPGRADE_COST * tower.level;
            if (gold >= upgradeCost) {
              gold -= upgradeCost;
              tower.level += 1;
              tower.damage *= 1.5;
              tower.range *= 1.2;
              tower.maxHp += 50;
              tower.hp = tower.maxHp;
              // At level 5 (upgrade cost = 250), double shooting speed
              if (tower.level === 5) {
                tower.fireRate = TOWER_FIRE_RATE / 2; // Shoot twice as fast
              }
            }
            break;
          }
        }
      });

      /** Main game loop using requestAnimationFrame **/
      let lastTime = 0;
      function gameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
        lastTime = timestamp;

        // Spawn enemies for current wave
        if (waveActive) {
          spawnTimer += dt;
          if (spawnCount < enemiesToSpawn && spawnTimer >= spawnInterval) {
            spawnEnemy();
            spawnCount++;
            spawnTimer = 0;
          }
        }

        // Update enemies
        for (let enemy of enemies) {
          if (enemy.remove) continue;
          const target = path[enemy.waypointIndex];
          const dx = target.x - enemy.x;
          const dy = target.y - enemy.y;
          const distance = Math.hypot(dx, dy);
          if (distance < enemy.speed * dt) {
            enemy.x = target.x;
            enemy.y = target.y;
            enemy.waypointIndex += 1;
            if (enemy.waypointIndex >= path.length) {
              enemy.remove = true;
            }
          } else {
            enemy.x += (dx / distance) * enemy.speed * dt;
            enemy.y += (dy / distance) * enemy.speed * dt;
          }
        }

        // Check collisions: enemies reaching towers
        for (let enemy of enemies) {
          if (enemy.remove) continue;
          for (let tower of towers) {
            if (tower.remove) continue;
            if (Math.abs(enemy.x - tower.x) < (ENEMY_SIZE/2 + TOWER_SIZE/2) &&
                Math.abs(enemy.y - tower.y) < (ENEMY_SIZE/2 + TOWER_SIZE/2)) {
              tower.hp -= ENEMY_DAMAGE_TO_TOWER;
              if (tower.hp <= 0) {
                tower.remove = true;
              }
            }
          }
        }

        // Towers attack
        for (let tower of towers) {
          if (tower.remove) continue;
          if (tower.cooldown > 0) {
            tower.cooldown -= dt;
          }
          if (tower.cooldown <= 0) {
            for (let enemy of enemies) {
              if (enemy.remove) continue;
              const d = dist(tower.x, tower.y, enemy.x, enemy.y);
              if (d <= tower.range) {
                const angle = Math.atan2(enemy.y - tower.y, enemy.x - tower.x);
                const bulletSpeed = 300;
                bullets.push({
                  x: tower.x,
                  y: tower.y,
                  dx: Math.cos(angle) * bulletSpeed,
                  dy: Math.sin(angle) * bulletSpeed,
                  damage: tower.damage,
                  target: enemy,
                  remove: false
                });
                tower.cooldown = tower.fireRate;
                break;
              }
            }
          }
        }

        // Update bullets
        for (let bullet of bullets) {
          if (bullet.remove) continue;
          bullet.x += bullet.dx * dt;
          bullet.y += bullet.dy * dt;
          if (bullet.target && !bullet.target.remove) {
            const distToTarget = dist(bullet.x, bullet.y, bullet.target.x, bullet.target.y);
            if (distToTarget < 15) {
              bullet.target.hp -= bullet.damage;
              if (bullet.target.hp <= 0) {
                bullet.target.remove = true;
                score += 1;
                gold += ENEMY_GOLD_DROP;
              }
              bullet.remove = true;
            }
          }
          if (bullet.x < 0 || bullet.x > CANVAS_WIDTH || bullet.y < 0 || bullet.y > CANVAS_HEIGHT) {
            bullet.remove = true;
          }
        }

        // Check end of wave
        const activeEnemies = enemies.filter(e => !e.remove);
        if (waveActive && spawnCount >= enemiesToSpawn && activeEnemies.length === 0) {
          waveActive = false;
          nextWaveTime = 5;
        }

        // Remove destroyed objects
        for (let i = towers.length - 1; i >= 0; i--) {
          if (towers[i].remove) towers.splice(i, 1);
        }
        for (let i = enemies.length - 1; i >= 0; i--) {
          if (enemies[i].remove) enemies.splice(i, 1);
        }
        for (let i = bullets.length - 1; i >= 0; i--) {
          if (bullets[i].remove) bullets.splice(i, 1);
        }

        // Update next wave timer
        if (!waveActive) {
          if (nextWaveTime > 0) {
            nextWaveTime -= dt;
            if (nextWaveTime <= 0) {
              startWave();
            }
          }
        }

        // Drawing everything on canvas
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw towers with size scaling and level 5 glow
        for (let t of towers) {
          const size = TOWER_SIZE * (1 + 0.1 * (t.level - 1)); // 10% larger per level
          if (t.level >= 5) {
            ctx.shadowColor = 'red';
            ctx.shadowBlur = 10;
          } else {
            ctx.shadowBlur = 0;
          }
          if (towerImg.complete && !imagesFailed) {
            ctx.drawImage(towerImg, t.x - size/2, t.y - size/2, size, size);
          } else {
            ctx.fillStyle = 'blue';
            ctx.fillRect(t.x - size/2, t.y - size/2, size, size);
          }
          const towerHealthRatio = t.hp / t.maxHp;
          ctx.fillStyle = 'red';
          ctx.fillRect(t.x - 20, t.y - size/2 - 10, 40, 5);
          ctx.fillStyle = 'lime';
          ctx.fillRect(t.x - 20, t.y - size/2 - 10, 40 * towerHealthRatio, 5);
        }
        ctx.shadowBlur = 0; // Reset shadow

        // Draw enemies
        for (let e of enemies) {
          if (enemyImg.complete && !imagesFailed) {
            ctx.drawImage(enemyImg, e.x - ENEMY_SIZE/2, e.y - ENEMY_SIZE/2, ENEMY_SIZE, ENEMY_SIZE);
          } else {
            ctx.fillStyle = 'red';
            ctx.fillRect(e.x - ENEMY_SIZE/2, e.y - ENEMY_SIZE/2, ENEMY_SIZE, ENEMY_SIZE);
          }
          const enemyHealthRatio = e.hp / e.maxHp;
          ctx.fillStyle = 'red';
          ctx.fillRect(e.x - 20, e.y - ENEMY_SIZE/2 - 10, 40, 5);
          ctx.fillStyle = 'lime';
          ctx.fillRect(e.x - 20, e.y - ENEMY_SIZE/2 - 10, 40 * enemyHealthRatio, 5);
        }

        // Draw bullets
        ctx.fillStyle = 'yellow';
        for (let b of bullets) {
          ctx.fillRect(b.x - 2, b.y - 2, 4, 4);
        }

        // Update UI text values
        scoreEl.textContent = score;
        goldEl.textContent = gold;
        waveEl.textContent = waveActive ? currentWave : currentWave;
        if (!waveActive && nextWaveTime > 0) {
          nextWaveEl.textContent = Math.ceil(nextWaveTime);
        } else if (waveActive) {
          nextWaveEl.textContent = '-';
        } else {
          nextWaveEl.textContent = '0';
        }

        // Loop again for next frame
        requestAnimationFrame(gameLoop);
      }
    })();
  </script>
</body>
</html>






