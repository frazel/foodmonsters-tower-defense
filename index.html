<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8" />
 <meta name="viewport" content="width=device-width, initial-scale=1.0" />
 <title>Tower Defense Game</title>
 <style>
 body { margin: 0; padding: 0; text-align: center; background: #000; }
 #gameCanvas {
 background: url('https://imgur.com/ARaVPJV.png') no-repeat center center;
 background-size: cover;
 display: block;
 margin: auto;
 }
 #ui, #towerMenu {
 position: fixed; top: 10px; background: rgba(0,0,0,0.5); color: #fff;
 padding: 10px; font-family: sans-serif; font-size: 14px;
 text-align: left; border-radius: 5px;
 }
 #ui { left: 10px; }
 #towerMenu { right: 10px; }
 #ui small { font-size: 11px; color: #ccc; }
 button { margin: 5px; padding: 5px 10px; cursor: pointer; }
 </style>
</head>
<body>
 <canvas id="gameCanvas" width="800" height="500"></canvas>
 <div id="ui">
 Score: <span id="score">0</span><br>
 Gold: <span id="gold">0</span><br>
 Wave: <span id="wave">0</span><br>
 Next wave in: <span id="nextWave">0</span>s<br>
 Base HP: <span id="baseHp">1000</span><br>
 <small>Left-click to place tower, Right-click a tower to upgrade</small>
 </div>
 <div id="towerMenu">
 <button onclick="selectedTowerType = 'basic'">Basic Tower (75g)</button><br>
 <button onclick="selectedTowerType = 'slow'">Slow Tower (100g)</button><br>
 <button onclick="selectedTowerType = 'aoe'">AoE Tower (150g)</button>
 </div>
 <script>
 // Game Constants
 const CANVAS_WIDTH = 800, CANVAS_HEIGHT = 500;
 const TOWER_SIZE = 40, ENEMY_SIZE = 40;
 const BASE_UPGRADE_COST = 50;
 const ENEMY_GOLD_DROP = 15;
 const TOWER_INITIAL_HP = 100, ENEMY_DAMAGE_TO_TOWER = 50;
 const BASE_HP = 1000;

 // Tower Types
 const TOWER_TYPES = {
 basic: { cost: 75, damage: 20, range: 100, fireRate: 1.0 },
 slow: { cost: 100, damage: 10, range: 80, fireRate: 1.5, slowEffect: 0.5 },
 aoe: { cost: 150, damage: 30, range: 120, fireRate: 2.0, aoeRadius: 50 }
 };

 // Enemy Types
 const ENEMY_TYPES = {
 basic: { hp: 50, speed: 50, gold: 15 },
 fast: { hp: 30, speed: 80, gold: 10 },
 armored: { hp: 100, speed: 40, gold: 20 }
 };

 // Game State
 let score = 0;
 let gold = 100;
 let currentWave = 0;
 let waveActive = false;
 let nextWaveTime = 3;
 let enemiesToSpawn = 0;
 let spawnCount = 0;
 const spawnInterval = 0.5;
 let spawnTimer = 0;
 let baseHp = BASE_HP;
 let gameOver = false;
 let selectedTowerType = 'basic';

 // Game Objects
 const towers = [];
 const enemies = [];
 const bullets = [];

 // Path Waypoints
 const path = [
 { x: 0, y: 250 },
 { x: 400, y: 250 },
 { x: 400, y: 400 },
 { x: 800, y: 400 }
 ];

 // Canvas and UI Elements
 const canvas = document.getElementById('gameCanvas');
 const ctx = canvas.getContext('2d');
 const scoreEl = document.getElementById('score');
 const goldEl = document.getElementById('gold');
 const waveEl = document.getElementById('wave');
 const nextWaveEl = document.getElementById('nextWave');
 const baseHpEl = document.getElementById('baseHp');

 // Load Assets
 const towerImg = new Image();
 const enemyImg = new Image();
 towerImg.src = "https://imgur.com/wLQWu8s.png";
 enemyImg.src = "https://imgur.com/hNQo8cQ.png";
 let assetsLoaded = 0;
 towerImg.onload = enemyImg.onload = () => {
 assetsLoaded++;
 if (assetsLoaded === 2) requestAnimationFrame(gameLoop);
 };

 // Helper Function: Distance Calculation
 function dist(ax, ay, bx, by) {
 return Math.hypot(bx - ax, by - ay);
 }

 // Spawn Enemy
 function spawnEnemy() {
 const enemyType = ['basic', 'fast', 'armored'][Math.floor(Math.random() * 3)];
 const config = ENEMY_TYPES[enemyType];
 const hp = config.hp + (currentWave - 1) * 10;
 const speed = config.speed + (currentWave - 1) * 5;
 enemies.push({
 x: path[0].x,
 y: path[0].y,
 hp: hp,
 maxHp: hp,
 speed: speed,
 type: enemyType,
 waypointIndex: 1,
 remove: false
 });
 }

 // Start Wave
 function startWave() {
 waveActive = true;
 currentWave += 1;
 spawnCount = 0;
 enemiesToSpawn = currentWave * 3 + 1;
 spawnTimer = 0;
 }

 // Place Tower
 canvas.addEventListener('click', e => {
 if (gameOver) return;
 const rect = canvas.getBoundingClientRect();
 const cx = e.clientX - rect.left;
 const cy = e.clientY - rect.top;
 const towerConfig = TOWER_TYPES[selectedTowerType];
 if (gold >= towerConfig.cost) {
 for (let tower of towers) {
 if (Math.abs(cx - tower.x) < TOWER_SIZE && Math.abs(cy - tower.y) < TOWER_SIZE) return;
 }
 gold -= towerConfig.cost;
 const tx = Math.max(TOWER_SIZE / 2, Math.min(CANVAS_WIDTH - TOWER_SIZE / 2, cx));
 const ty = Math.max(TOWER_SIZE / 2, Math.min(CANVAS_HEIGHT - TOWER_SIZE / 2, cy));
 towers.push({
 x: tx,
 y: ty,
 type: selectedTowerType,
 hp: TOWER_INITIAL_HP,
 maxHp: TOWER_INITIAL_HP,
 damage: towerConfig.damage,
 range: towerConfig.range,
 fireRate: towerConfig.fireRate,
 slowEffect: towerConfig.slowEffect || 0,
 aoeRadius: towerConfig.aoeRadius || 0,
 cooldown: 0,
 level: 1,
 remove: false
 });
 }
 });

 // Upgrade Tower
 canvas.addEventListener('contextmenu', e => {
 e.preventDefault();
 if (gameOver) return;
 const rect = canvas.getBoundingClientRect();
 const cx = e.clientX - rect.left;
 const cy = e.clientY - rect.top;
 for (let tower of towers) {
 if (Math.abs(cx - tower.x) < TOWER_SIZE / 2 && Math.abs(cy - tower.y) < TOWER_SIZE / 2) {
 const upgradeCost = BASE_UPGRADE_COST * tower.level;
 if (gold >= upgradeCost) {
 gold -= upgradeCost;
 tower.level += 1;
 tower.damage *= 1.5;
 tower.range *= 1.2;
 tower.maxHp += 50;
 tower.hp = tower.maxHp;
 }
 break;
 }
 }
 });

 // Main Game Loop
 let lastTime = 0;
 function gameLoop(timestamp) {
 if (gameOver) {
 ctx.fillStyle = 'red';
 ctx.font = '48px sans-serif';
 ctx.fillText('Game Over', CANVAS_WIDTH / 2 - 100, CANVAS_HEIGHT / 2);
 return;
 }
 const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
 lastTime = timestamp;

 // Spawn Enemies
 if (waveActive) {
 spawnTimer += dt;
 if (spawnCount < enemiesToSpawn && spawnTimer >= spawnInterval) {
 spawnEnemy();
 spawnCount++;
 spawnTimer = 0;
 }
 }

 // Update Enemies
 for (let enemy of enemies) {
 if (enemy.remove) continue;
 const target = path[enemy.waypointIndex];
 const dx = target.x - enemy.x;
 const dy = target.y - enemy.y;
 const distance = Math.hypot(dx, dy);
 if (distance < enemy.speed * dt) {
 enemy.x = target.x;
 enemy.y = target.y;
 enemy.waypointIndex += 1;
 if (enemy.waypointIndex >= path.length) {
 baseHp -= 50;
 if (baseHp <= 0) gameOver = true;
 enemy.remove = true;
 }
 } else {
 enemy.x += (dx / distance) * enemy.speed * dt;
 enemy.y += (dy / distance) * enemy.speed * dt;
 }
 }

 // Towers Attack
 for (let tower of towers) {
 if (tower.remove) continue;
 if (tower.cooldown > 0) tower.cooldown -= dt;
 if (tower.cooldown <= 0) {
 let target = null;
 let minDist = Infinity;
 for (let enemy of enemies) {
 if (enemy.remove) continue;
 const d = dist(tower.x, tower.y, enemy.x, enemy.y);
 if (d <= tower.range && d < minDist) {
 minDist = d;
 target = enemy;
 }
 }
 if (target) {
 const angle = Math.atan2(target.y - tower.y, target.x - tower.x);
 bullets.push({
 x: tower.x,
 y: tower.y,
 dx: Math.cos(angle) * 300,
 dy: Math.sin(angle) * 300,
 damage: tower.damage,
 target: target,
 aoeRadius: tower.aoeRadius || 0,
 slowEffect: tower.slowEffect || 0,
 remove: false
 });
 tower.cooldown = tower.fireRate;
 }
 }
 }

 // Update Bullets
 for (let bullet of bullets) {
 if (bullet.remove) continue;
 bullet.x += bullet.dx * dt;
 bullet.y += bullet.dy * dt;
 if (bullet.target && !bullet.target.remove) {
 const distToTarget = dist(bullet.x, bullet.y, bullet.target.x, bullet.target.y);
 if (distToTarget < 15) {
 bullet.target.hp -= bullet.damage;
 if (bullet.slowEffect) bullet.target.speed *= bullet.slowEffect;
 if (bullet.aoeRadius) {
 for (let enemy of enemies) {
 if (dist(bullet.x, bullet.y, enemy.x, enemy.y) < bullet.aoeRadius) {
 enemy.hp -= bullet.damage;
 if (enemy.hp <= 0) {
 enemy.remove = true;
 score += 1;
 gold += ENEMY_GOLD_DROP;
 }
 }
 }
 }
 if (bullet.target.hp <= 0) {
 bullet.target.remove = true;
 score += 1;
 gold += ENEMY_GOLD_DROP;
 }
 bullet.remove = true;
 }
 }
 if (bullet.x < 0 || bullet.x > CANVAS_WIDTH || bullet.y < 0 || bullet.y > CANVAS_HEIGHT) {
 bullet.remove = true;
 }
 }

 // Check End of Wave
 const activeEnemies = enemies.filter(e => !e.remove);
 if (waveActive && spawnCount >= enemiesToSpawn && activeEnemies.length === 0) {
 waveActive = false;
 nextWaveTime = 5;
 }

 // Remove Destroyed Objects
 towers = towers.filter(t => !t.remove);
 enemies = enemies.filter(e => !e.remove);
 bullets = bullets.filter(b => !b.remove);

 // Update Next Wave Timer
 if (!waveActive) {
 if (next WaveTime > 0) {
 nextWaveTime -= dt;
 if (nextWaveTime <= 0) startWave();
 }
 }

 // Drawing
 ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
 // Draw Towers
 for (let t of towers) {
 ctx.drawImage(towerImg, t.x - TOWER_SIZE / 2, t.y - TOWER_SIZE / 2, TOWER_SIZE, TOWER_SIZE);
 const healthRatio = t.hp / t.maxHp;
 ctx.fillStyle = 'red';
 ctx.fillRect(t.x - 20, t.y - TOWER_SIZE / 2 - 10, 40, 5);
 ctx.fillStyle = 'lime';
 ctx.fillRect(t.x - 20, t.y - TOWER_SIZE / 2 - 10, 40 * healthRatio, 5);
 }
 // Draw Enemies
 for (let e of enemies) {
 ctx.drawImage(enemyImg, e.x - ENEMY_SIZE / 2, e.y - ENEMY_SIZE / 2, ENEMY_SIZE, ENEMY_SIZE);
 const healthRatio = e.hp / e.maxHp;
 ctx.fillStyle = 'red';
 ctx.fillRect(e.x - 20, e.y - ENEMY_SIZE / 2 - 10, 40, 5);
 ctx.fillStyle = 'lime';
 ctx.fillRect(e.x - 20, e.y - ENEMY_SIZE / 2 - 10, 40 * healthRatio, 5);
 }
 // Draw Bullets
 ctx.fillStyle = 'yellow';
 for (let b of bullets) {
 ctx.fillRect(b.x - 2, b.y - 2, 4, 4);
 }
 // Draw Base
 ctx.fillStyle = 'blue';
 ctx.fillRect(CANVAS_WIDTH - 50, CANVAS_HEIGHT - 50, 50, 50);
 const baseHealthRatio = baseHp / BASE_HP;
 ctx.fillStyle = 'red';
 ctx.fillRect(CANVAS_WIDTH - 50, CANVAS_HEIGHT - 60, 50, 5);
 ctx.fillStyle = 'lime';
 ctx.fillRect(CANVAS_WIDTH - 50, CANVAS_HEIGHT - 60, 50 * baseHealthRatio, 5);

 // Update UI
 scoreEl.textContent = score;
 goldEl.textContent = gold;
 waveEl.textContent = waveActive ? currentWave : currentWave;
 nextWaveEl.textContent = waveActive ? '-' : Math.ceil(nextWaveTime);
 baseHpEl.textContent = baseHp;

 requestAnimationFrame(gameLoop);
 }
 </script>
</body>
</html>






